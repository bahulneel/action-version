[{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/.prettierrc.json","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/index.cjs","messages":[{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":315,"column":26,"nodeType":"Identifier","messageId":"preferModule","endLine":315,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'getLastVersionChangeCommit' is not defined.","line":330,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":330,"endColumn":44},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":481,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":481,"endColumn":15},{"ruleId":"no-template-curly-in-string","severity":2,"message":"Unexpected template string expression.","line":487,"column":65,"nodeType":"Literal","messageId":"unexpectedTemplateExpression","endLine":487,"endColumn":126},{"ruleId":"no-template-curly-in-string","severity":2,"message":"Unexpected template string expression.","line":488,"column":79,"nodeType":"Literal","messageId":"unexpectedTemplateExpression","endLine":488,"endColumn":153},{"ruleId":"no-template-curly-in-string","severity":2,"message":"Unexpected template string expression.","line":490,"column":62,"nodeType":"Literal","messageId":"unexpectedTemplateExpression","endLine":490,"endColumn":82},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":553,"column":25,"nodeType":"Identifier","messageId":"preferModule","endLine":553,"endColumn":32},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":553,"column":56,"nodeType":"Identifier","messageId":"preferModule","endLine":553,"endColumn":63},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":648,"column":43,"nodeType":"Identifier","messageId":"preferModule","endLine":648,"endColumn":50},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":652,"column":43,"nodeType":"Identifier","messageId":"preferModule","endLine":652,"endColumn":50},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":695,"column":41,"nodeType":"Identifier","messageId":"preferModule","endLine":695,"endColumn":48},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":716,"column":45,"nodeType":"Identifier","messageId":"preferModule","endLine":716,"endColumn":52},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":739,"column":43,"nodeType":"Identifier","messageId":"preferModule","endLine":739,"endColumn":50},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":983,"column":52,"nodeType":"Identifier","messageId":"preferModule","endLine":983,"endColumn":59},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":995,"column":13,"nodeType":"Identifier","messageId":"preferModule","endLine":995,"endColumn":20},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":1037,"column":31,"nodeType":"Identifier","messageId":"preferModule","endLine":1037,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'currentBranch' is assigned a value but never used.","line":1075,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":1075,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"currentBranch"},"fix":{"range":[35941,35955],"text":""},"desc":"Remove unused variable 'currentBranch'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'currentBranch' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1075,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":1075,"endColumn":26},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":1078,"column":21,"nodeType":"Identifier","messageId":"preferModule","endLine":1078,"endColumn":28},{"ruleId":"no-unused-vars","severity":2,"message":"'nameToDir' is assigned a value but never used.","line":1093,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":1093,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"nameToDir"},"fix":{"range":[36792,36803],"text":""},"desc":"Remove unused variable 'nameToDir'."}]},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'nameToDir' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1093,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":1093,"endColumn":29},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":1196,"column":3,"nodeType":"Identifier","messageId":"preferModule","endLine":1196,"endColumn":10}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"require('source-map-support').install()\nconst { execSync } = require('node:child_process')\nconst fs = require('node:fs/promises')\nconst path = require('node:path')\n// index.js\nconst core = require('@actions/core')\nconst conventionalCommitsParser = require('conventional-commits-parser')\nconst { globSync } = require('glob')\nconst semver = require('semver')\nconst simpleGit = require('simple-git')\n\nconst git = simpleGit()\n\nconst depKeys = ['dependencies', 'devDependencies', 'peerDependencies']\n\n// Strategy Pattern: Version Bump Strategies\nclass VersionBumpStrategy {\n  constructor(name) {\n    this.name = name\n  }\n\n  execute(_currentVersion, _commitBasedBump, _historicalBump) {\n    throw new Error('Strategy must implement execute method')\n  }\n}\n\nclass DoNothingStrategy extends VersionBumpStrategy {\n  constructor() {\n    super('do-nothing')\n  }\n\n  execute(_currentVersion, _commitBasedBump, _historicalBump) {\n    core.debug(`Strategy 'do-nothing': Skipping bump`)\n    return _currentVersion // No change\n  }\n}\n\nclass ApplyBumpStrategy extends VersionBumpStrategy {\n  constructor() {\n    super('apply-bump')\n  }\n\n  execute(currentVersion, _commitBasedBump, _historicalBump) {\n    const current = semver.coerce(currentVersion) || '0.0.0'\n    const nextVersion = semver.inc(current, _commitBasedBump)\n    core.debug(`Strategy 'apply-bump': Normal semver bump ${current} → ${nextVersion}`)\n    return nextVersion // 1.1.0 → 1.2.0\n  }\n}\n\nclass PreReleaseStrategy extends VersionBumpStrategy {\n  constructor() {\n    super('pre-release')\n  }\n\n  execute(currentVersion, commitBasedBump, _historicalBump) {\n    const current = semver.coerce(currentVersion) || '0.0.0'\n\n    if (semver.prerelease(current)) {\n      const nextVersion = semver.inc(current, 'prerelease')\n      core.debug(`Strategy 'pre-release': Increment prerelease ${current} → ${nextVersion}`)\n      return nextVersion // 1.2.0-1 → 1.2.0-2\n    }\n    else {\n      // First time: apply bump then make prerelease\n      const bumped = semver.inc(current, commitBasedBump) // 1.1.0 → 1.2.0\n      const nextVersion = semver.inc(bumped, 'prerelease', '0') // 1.2.0 → 1.2.0-0\n      core.debug(`Strategy 'pre-release': First prerelease ${current} → ${bumped} → ${nextVersion}`)\n      return nextVersion\n    }\n  }\n}\n\nclass VersionBumpStrategyFactory {\n  static strategies = {\n    'do-nothing': new DoNothingStrategy(),\n    'apply-bump': new ApplyBumpStrategy(),\n    'pre-release': new PreReleaseStrategy(),\n  }\n\n  static getStrategy(strategyName) {\n    const strategy = this.strategies[strategyName]\n    if (!strategy) {\n      throw new Error(`Unknown version bump strategy: ${strategyName}`)\n    }\n    return strategy\n  }\n\n  static getAvailableStrategies() {\n    return Object.keys(this.strategies)\n  }\n}\n\n// Strategy Pattern: Branch Cleanup Strategies\nclass BranchCleanupStrategy {\n  constructor(name) {\n    this.name = name\n  }\n\n  async execute(_branches, _versionedBranch, _templateRegex, _rootBump) {\n    throw new Error('Strategy must implement execute method')\n  }\n}\n\nclass KeepAllBranchesStrategy extends BranchCleanupStrategy {\n  constructor() {\n    super('keep')\n  }\n\n  async execute(_branches, _versionedBranch, _templateRegex, _rootBump) {\n    core.info(`[root] Branch cleanup strategy: ${this.name} - keeping all branches`)\n    // Do nothing - keep all branches\n  }\n}\n\nclass PruneOldBranchesStrategy extends BranchCleanupStrategy {\n  constructor() {\n    super('prune')\n  }\n\n  async execute(branches, versionedBranch, templateRegex, _rootBump) {\n    core.info(`[root] Branch cleanup strategy: ${this.name} - removing old branches`)\n\n    for (const branch of branches.all) {\n      if (branch.replace('origin/', '') === versionedBranch) {\n        continue // Skip current branch\n      }\n\n      const match = branch.match(templateRegex)\n      const { version } = match?.groups || {}\n      if (version) {\n        core.info(`[root] Deleting old branch ${branch}`)\n        await this._deleteBranch(branch)\n      }\n    }\n  }\n\n  async _deleteBranch(branch) {\n    try {\n      await git.deleteLocalBranch(branch, true)\n    }\n    catch { }\n    try {\n      deleteRemoteBranch(branch.replace('origin/', ''))\n    }\n    catch { }\n  }\n}\n\nclass SemanticBranchesStrategy extends BranchCleanupStrategy {\n  constructor() {\n    super('semantic')\n  }\n\n  async execute(branches, versionedBranch, templateRegex, rootBump) {\n    core.info(`[root] Branch cleanup strategy: ${this.name} - keeping same bump type only`)\n\n    for (const branch of branches.all) {\n      if (branch.replace('origin/', '') === versionedBranch) {\n        continue // Skip current branch\n      }\n\n      const match = branch.match(templateRegex)\n      const { version } = match?.groups || {}\n      if (version) {\n        const bumpType = guessBumpType(version)\n        if (bumpType !== rootBump) {\n          continue // Keep different bump types\n        }\n\n        core.info(`[root] Deleting same-type branch ${branch} (${bumpType})`)\n        await this._deleteBranch(branch)\n      }\n    }\n  }\n\n  async _deleteBranch(branch) {\n    try {\n      await git.deleteLocalBranch(branch, true)\n    }\n    catch { }\n    try {\n      deleteRemoteBranch(branch.replace('origin/', ''))\n    }\n    catch { }\n  }\n}\n\nclass BranchCleanupStrategyFactory {\n  static strategies = {\n    keep: new KeepAllBranchesStrategy(),\n    prune: new PruneOldBranchesStrategy(),\n    semantic: new SemanticBranchesStrategy(),\n  }\n\n  static getStrategy(strategyName) {\n    const strategy = this.strategies[strategyName]\n    if (!strategy) {\n      throw new Error(`Unknown branch cleanup strategy: ${strategyName}`)\n    }\n    return strategy\n  }\n\n  static getAvailableStrategies() {\n    return Object.keys(this.strategies)\n  }\n}\n\n// Strategy Pattern: Reference Point Determination Strategies\nclass ReferencePointStrategy {\n  constructor(name) {\n    this.name = name\n  }\n\n  async execute(_baseBranch, _activeBranch) {\n    throw new Error('Strategy must implement execute method')\n  }\n}\n\nclass TagBasedReferenceStrategy extends ReferencePointStrategy {\n  constructor() {\n    super('tag-based')\n  }\n\n  async execute(_baseBranch, _activeBranch) {\n    core.info(`[root] Using latest tag as reference`)\n    const tags = await git.tags(['--sort=-v:refname'])\n    const latestTag = tags.latest\n\n    if (latestTag) {\n      const referenceCommit = await git.revparse([latestTag])\n      const referenceVersion = semver.coerce(latestTag.replace(/^v/, '')) || '0.0.0'\n      return { referenceCommit, referenceVersion, shouldFinalizeVersions: false }\n    }\n    else {\n      // No tags, use first commit\n      const firstCommit = await git.log(['--reverse', '--max-count=1'])\n      const referenceCommit = firstCommit.latest.hash\n      const referenceVersion = '0.0.0'\n      return { referenceCommit, referenceVersion, shouldFinalizeVersions: false }\n    }\n  }\n}\n\nclass BranchBasedReferenceStrategy extends ReferencePointStrategy {\n  constructor() {\n    super('branch-based')\n  }\n\n  async execute(baseBranch, activeBranch) {\n    core.info(`[root] Using branch base: ${baseBranch}`)\n    const branch = baseBranch.startsWith('origin/') ? baseBranch : `origin/${baseBranch}`\n    let referenceCommit = await lastNonMergeCommit(git, branch)\n    referenceCommit = referenceCommit.trim()\n\n    // Get root package version at that commit\n    const rootPackageJsonPath = require('node:path').join(require('node:process').cwd(), 'package.json')\n    let referenceVersion = await getVersionAtCommit(rootPackageJsonPath, referenceCommit)\n    referenceVersion = semver.coerce(referenceVersion) || '0.0.0'\n\n    // Check if we should finalize prerelease versions (base branch update scenario)\n    let shouldFinalizeVersions = false\n    if (baseBranch && activeBranch) {\n      try {\n        const activeCommit = await lastNonMergeCommit(git, `origin/${activeBranch}`)\n        const baseCommit = await lastNonMergeCommit(git, `origin/${baseBranch}`)\n\n        if (activeCommit === baseCommit) {\n          core.info(`[root] Active and base branches are at same commit - checking for prerelease finalization`)\n          shouldFinalizeVersions = true\n        }\n      }\n      catch (error) {\n        core.debug(`Could not compare active/base branches: ${error.message}`)\n      }\n    }\n\n    return { referenceCommit, referenceVersion, shouldFinalizeVersions }\n  }\n}\n\nclass ReferencePointStrategyFactory {\n  static getStrategy(baseBranch) {\n    if (baseBranch) {\n      return new BranchBasedReferenceStrategy()\n    }\n    else {\n      return new TagBasedReferenceStrategy()\n    }\n  }\n}\n\nconst { GitOperationStrategyFactory } = require('./lib/git-operations/factory.cjs')\n// Strategy Pattern: Import from lib folder\nconst { PackageManagerFactory } = require('./lib/package-managers/factory.cjs')\n\nclass Package {\n  constructor(name, dir, pkg, packageJsonPath) {\n    this.name = name\n    this.dir = dir\n    this.pkg = pkg\n    this.packageJsonPath = packageJsonPath\n    this.bumpResult = null\n  }\n\n  get version() {\n    return this.pkg.version\n  }\n\n  set version(newVersion) {\n    this.pkg.version = newVersion\n  }\n\n  get relativePath() {\n    return path.relative(process.cwd(), this.dir) || '/'\n  }\n\n  initializeVersion() {\n    if (!this.pkg.version) {\n      this.pkg.version = initializeVersion(this.pkg.version)\n      core.info(`[${this.name}] Initialized missing version to ${this.pkg.version}`)\n    }\n  }\n\n  async save() {\n    await writeJSON(this.packageJsonPath, this.pkg)\n  }\n\n  async getLastVersionChangeCommit() {\n    return await getLastVersionChangeCommit(this.packageJsonPath)\n  }\n\n  async getCommitsAffecting(sinceRef) {\n    return await getCommitsAffecting(this.dir, sinceRef)\n  }\n\n  async getVersionAtCommit(commitRef) {\n    return await getVersionAtCommit(this.packageJsonPath, commitRef)\n  }\n\n  async processVersionBump(referenceCommit, referenceVersion, strategy, commitMsgTemplate, gitStrategy) {\n    this.initializeVersion()\n\n    core.info(`[${this.name}@${this.version}] Processing package`)\n\n    // Step 2a: Detect when version was last changed\n    const lastVersionCommit = await this.getLastVersionChangeCommit()\n\n    // Step 2b: Find changes since last version change\n    const commitsSinceVersion = await this.getCommitsAffecting(lastVersionCommit)\n    const commitBasedBump = commitsSinceVersion.length > 0 ? getMostSignificantBump(commitsSinceVersion) : null\n\n    // Step 2c: Calculate historical bump type from reference\n    const historicalVersion = await this.getVersionAtCommit(referenceCommit) || referenceVersion\n    const historicalBump = calculateBumpType(historicalVersion, this.version)\n\n    core.info(`[${this.name}@${this.version}] Commit-based bump: ${commitBasedBump || 'none'}, Historical bump: ${historicalBump || 'none'}`)\n\n    // Step 2d: Apply strategy for same bump type\n    if (commitBasedBump && commitBasedBump === historicalBump) {\n      core.info(`[${this.name}@${this.version}] Same bump type detected, applying strategy: ${strategy}`)\n\n      const nextVersion = getNextVersion(this.version, commitBasedBump, historicalBump, strategy)\n\n      if (nextVersion === this.version) {\n        core.info(`[${this.name}@${this.version}] Skipping - strategy '${strategy}' with no changes needed`)\n        return null\n      }\n\n      this.version = nextVersion\n      await this.save()\n\n      const bumpType = semver.prerelease(nextVersion) ? 'prerelease' : commitBasedBump\n\n      // Use git strategy to commit the version change\n      await gitStrategy.commitVersionChange(this.dir, this.name, this.version, bumpType, commitMsgTemplate)\n\n      const result = {\n        version: this.version,\n        bumpType,\n        sha: lastVersionCommit,\n      }\n\n      if (semver.prerelease(this.version)) {\n        core.info(`[${this.name}@${this.version}] Bumped to ${this.version} (prerelease)`)\n      }\n      else {\n        core.info(`[${this.name}@${this.version}] Bumped to ${this.version} (${commitBasedBump})`)\n      }\n\n      this.bumpResult = result\n      return result\n    }\n\n    // Step 2e: Use commit-based bump if different from historical\n    if (commitBasedBump && commitBasedBump !== historicalBump) {\n      const nextVersion = getNextVersion(this.version, commitBasedBump, historicalBump, 'apply-bump')\n      this.version = nextVersion\n      await this.save()\n\n      // Use git strategy to commit the version change\n      await gitStrategy.commitVersionChange(this.dir, this.name, this.version, commitBasedBump, commitMsgTemplate)\n\n      const result = {\n        version: this.version,\n        bumpType: commitBasedBump,\n        sha: lastVersionCommit,\n      }\n\n      core.info(`[${this.name}@${this.version}] Bumped to ${this.version} (${commitBasedBump})`)\n      this.bumpResult = result\n      return result\n    }\n\n    // No changes needed\n    return null\n  }\n\n  async finalizePrerelease(commitMsgTemplate, gitStrategy) {\n    if (this.version && semver.prerelease(this.version)) {\n      const finalVersion = finalizeVersion(this.version)\n      core.info(`[${this.name}] Finalizing prerelease version: ${this.version} → ${finalVersion}`)\n\n      this.version = finalVersion\n      await this.save()\n\n      // Use git strategy to commit the finalization\n      await gitStrategy.commitVersionChange(this.dir, this.name, finalVersion, 'release', commitMsgTemplate)\n\n      const result = { version: finalVersion, bumpType: 'release', sha: null }\n      this.bumpResult = result\n      return result\n    }\n    return null\n  }\n\n  async updateDependency(depName, newVersion, depCommitMsgTemplate, gitStrategy) {\n    let updated = false\n\n    for (const depKey of depKeys) {\n      if (this.pkg[depKey] && this.pkg[depKey][depName]) {\n        const currentDepSpec = this.pkg[depKey][depName]\n\n        if (semver.satisfies(newVersion, currentDepSpec)) {\n          continue\n        }\n\n        core.info(`[${this.name}] Updating ${depName} dependency from ${currentDepSpec} to ^${newVersion}`)\n        this.pkg[depKey][depName] = `^${newVersion}`\n        updated = true\n      }\n    }\n\n    if (updated) {\n      await this.save()\n\n      // Use git strategy to commit the dependency update\n      await gitStrategy.commitDependencyUpdate(this.dir, this.name, depName, newVersion, depCommitMsgTemplate)\n      core.info(`[${this.name}] Updated dependencies for ${depName}`)\n    }\n\n    return updated\n  }\n\n  async testCompatibility(packageManager) {\n    try {\n      const testResult = await packageManager.test(this.dir)\n      return testResult\n    }\n    catch (error) {\n      core.warning(`[${this.name}] Test execution failed: ${error.message}`)\n      return { success: false, error: error.message }\n    }\n  }\n}\n\nfunction safeGetBooleanInput(input, defaultValue) {\n  try {\n    return core.getBooleanInput(input) ?? defaultValue\n  }\n  catch (error) {\n    return defaultValue\n  }\n}\n\nasync function parseConfiguration() {\n  const commitMsgTemplate = core.getInput('commit_template') || 'chore(release): bump ${package} to ${version} (${bumpType})'\n  const depCommitMsgTemplate = core.getInput('dependency_commit_template') || 'chore(deps): update ${depPackage} to ${depVersion} in ${package} (patch)'\n  const shouldCreateBranch = safeGetBooleanInput('create_branch', false)\n  const branchTemplate = core.getInput('branch_template') || 'release/${version}'\n  const templateRegex = new RegExp(branchTemplate.replace(/\\$\\{(\\w+)\\}/g, '(?<$1>\\\\w+)'))\n  const branchCleanup = core.getInput('branch_cleanup') || 'keep'\n  const baseBranch = core.getInput('base') || shouldCreateBranch ? 'main' : undefined\n  const strategy = core.getInput('strategy') || 'do-nothing'\n  const activeBranch = core.getInput('branch') || 'develop'\n  const tagPrereleases = safeGetBooleanInput('tag_prereleases', false)\n\n  // Validate configuration inputs\n  const validStrategies = VersionBumpStrategyFactory.getAvailableStrategies()\n  if (!validStrategies.includes(strategy)) {\n    throw new Error(`Invalid strategy: ${strategy}. Must be one of: ${validStrategies.join(', ')}`)\n  }\n\n  const validCleanupStrategies = BranchCleanupStrategyFactory.getAvailableStrategies()\n  if (!validCleanupStrategies.includes(branchCleanup)) {\n    throw new Error(`Invalid branch cleanup strategy: ${branchCleanup}. Must be one of: ${validCleanupStrategies.join(', ')}`)\n  }\n\n  if (activeBranch && activeBranch.trim() === '') {\n    throw new Error('branch cannot be empty if provided')\n  }\n\n  if (baseBranch && baseBranch.trim() === '') {\n    throw new Error('base cannot be empty if provided')\n  }\n\n  // Validate branch compatibility\n  if (strategy === 'pre-release' && !baseBranch) {\n    core.warning('Using pre-release strategy without base - prerelease finalization will not be available')\n  }\n\n  core.info(`[config] Strategy: ${strategy}`)\n  core.info(`[config] Active branch: ${activeBranch}`)\n  core.info(`[config] Tag prereleases: ${tagPrereleases}`)\n\n  return {\n    commitMsgTemplate,\n    depCommitMsgTemplate,\n    shouldCreateBranch,\n    branchTemplate,\n    templateRegex,\n    branchCleanup,\n    baseBranch,\n    strategy,\n    activeBranch,\n    tagPrereleases,\n  }\n}\n\nasync function setupGit(shouldCreateBranch, branchTemplate) {\n  await git.addConfig('user.name', 'github-actions[bot]')\n  await git.addConfig('user.email', 'github-actions[bot]@users.noreply.github.com')\n\n  try {\n    core.debug(`[git] Fetching latest changes from origin`)\n    await git.fetch(['--prune', 'origin'])\n    core.debug(`[git] Successfully fetched from origin`)\n  }\n  catch (error) {\n    core.warning(`[git] Failed to fetch from origin: ${error.message}`)\n  }\n\n  const currentBranch = process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME || 'main'\n  const newBranch = shouldCreateBranch ? interpolate(branchTemplate, { version: currentBranch }) : undefined\n\n  try {\n    if (newBranch) {\n      core.info(`[git] Checking out ${newBranch} from ${currentBranch}`)\n      await git.checkoutBranch(newBranch, currentBranch)\n      core.debug(`[git] Successfully checked out ${newBranch}`)\n    }\n    else {\n      core.info(`[git] Checking out ${currentBranch}`)\n      await git.checkout(currentBranch)\n      core.debug(`[git] Successfully checked out ${currentBranch}`)\n    }\n  }\n  catch (error) {\n    core.error(`[git] Failed to checkout branch: ${error.message}`)\n    throw new Error(`Failed to checkout branch: ${error.message}`)\n  }\n\n  return { currentBranch, newBranch }\n}\n\nasync function determineReferencePoint(baseBranch, activeBranch) {\n  const strategy = ReferencePointStrategyFactory.getStrategy(baseBranch)\n  const result = await strategy.execute(baseBranch, activeBranch)\n\n  core.info(`[root] Reference: ${result.referenceCommit} (version: ${result.referenceVersion})`)\n\n  return result\n}\n\nasync function processWorkspacePackages(packages, referenceCommit, referenceVersion, strategy, commitMsgTemplate, depCommitMsgTemplate, gitStrategy, packageManager) {\n  const bumped = {}\n  const testFailures = []\n\n  for (const pkg of packages) {\n    const result = await pkg.processVersionBump(referenceCommit, referenceVersion, strategy, commitMsgTemplate, gitStrategy)\n    if (result) {\n      bumped[pkg.name] = result\n    }\n  }\n\n  // Update dependencies for bumped packages\n  for (const pkg of packages) {\n    if (bumped[pkg.name]) {\n      for (const siblingPkg of packages) {\n        if (siblingPkg.name !== pkg.name) {\n          const updated = await siblingPkg.updateDependency(pkg.name, pkg.version, depCommitMsgTemplate, gitStrategy)\n\n          if (updated && bumped[pkg.name].bumpType === 'major') {\n            // Test major version compatibility using package manager strategy\n            const testResult = await siblingPkg.testCompatibility(packageManager)\n            if (!testResult.success) {\n              core.warning(`[${siblingPkg.name}] Tests failed after major bump of ${pkg.name}, locking to previous version`)\n              testFailures.push(siblingPkg.name)\n\n              // Revert to previous version with exact pinning\n              const prevVersion = testResult.prevVersion || pkg.version\n              for (const depKey of depKeys) {\n                if (siblingPkg.pkg[depKey] && siblingPkg.pkg[depKey][pkg.name]) {\n                  siblingPkg.pkg[depKey][pkg.name] = prevVersion\n                }\n              }\n              await siblingPkg.save()\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return { bumped, testFailures }\n}\n\nasync function finalizePackageVersions(packages, rootPkg, commitMsgTemplate, gitStrategy) {\n  const bumped = {}\n  let hasBumped = false\n\n  core.info(`[root] Finalizing prerelease versions for base branch update`)\n\n  for (const pkg of packages) {\n    const result = await pkg.finalizePrerelease(commitMsgTemplate, gitStrategy)\n    if (result) {\n      bumped[pkg.name] = result\n      hasBumped = true\n    }\n  }\n\n  // Finalize root package if it's a prerelease\n  if (rootPkg.version && semver.prerelease(rootPkg.version)) {\n    const finalVersion = finalizeVersion(rootPkg.version)\n    core.info(`[root] Finalizing prerelease version: ${rootPkg.version} → ${finalVersion}`)\n\n    rootPkg.version = finalVersion\n    const rootPackageJsonPath = path.join(process.cwd(), 'package.json')\n    await writeJSON(rootPackageJsonPath, rootPkg)\n\n    // Use git strategy to commit the root finalization\n    await gitStrategy.commitVersionChange(process.cwd(), rootPkg.name || 'root', finalVersion, 'release', commitMsgTemplate)\n\n    bumped[rootPkg.name] = { version: finalVersion, bumpType: 'release', sha: null }\n    hasBumped = hasBumped || true\n  }\n\n  if (hasBumped) {\n    core.info(`[root] Prerelease finalization complete`)\n\n    // Create release tags for finalized versions using git strategy\n    if (rootPkg.version) {\n      await gitStrategy.tagVersion(rootPkg.version, false, true) // Force tagging for finalized releases\n    }\n  }\n  else {\n    core.info(`[root] No prerelease versions found to finalize`)\n  }\n\n  return { bumped, hasBumped }\n}\n\nasync function processRootPackage(rootPkg, bumped, referenceCommit, referenceVersion, strategy, commitMsgTemplate, gitStrategy) {\n  if (!rootPkg.workspaces) {\n    return { bumped, hasBumped: false }\n  }\n\n  core.info(`[root@${rootPkg.version}] Processing root package`)\n\n  // Initialize root version if missing\n  if (!rootPkg.version) {\n    rootPkg.version = initializeVersion(rootPkg.version)\n    core.info(`[root] Initialized missing version to ${rootPkg.version}`)\n  }\n\n  // Step 1: Compute most significant bump from workspaces\n  let workspaceBump = null\n  for (const name in bumped) {\n    if (bumpPriority(bumped[name].bumpType) > bumpPriority(workspaceBump)) {\n      workspaceBump = bumped[name].bumpType\n    }\n  }\n\n  // Step 2: Calculate historical bump type from reference\n  const rootPackageJsonPath = path.join(process.cwd(), 'package.json')\n  const rootHistoricalVersion = await getVersionAtCommit(rootPackageJsonPath, referenceCommit) || referenceVersion\n  const rootHistoricalBump = calculateBumpType(rootHistoricalVersion, rootPkg.version)\n\n  core.info(`[root@${rootPkg.version}] Required bump: ${workspaceBump}, Historical bump: ${rootHistoricalBump || 'none'}`)\n\n  let hasBumped = false\n\n  // Step 3: Apply strategy if same bump type\n  if (workspaceBump && workspaceBump === rootHistoricalBump) {\n    core.info(`[root@${rootPkg.version}] Same bump type detected, applying strategy: ${strategy}`)\n\n    const nextVersion = getNextVersion(rootPkg.version, workspaceBump, rootHistoricalBump, strategy)\n\n    if (nextVersion !== rootPkg.version) {\n      rootPkg.version = nextVersion\n      await writeJSON(rootPackageJsonPath, rootPkg)\n\n      const bumpType = semver.prerelease(nextVersion) ? 'prerelease' : workspaceBump\n\n      // Use git strategy to commit the root version change\n      await gitStrategy.commitVersionChange(process.cwd(), rootPkg.name || 'root', rootPkg.version, bumpType, commitMsgTemplate)\n\n      bumped[rootPkg.name] = { version: rootPkg.version, bumpType, sha: null }\n      hasBumped = true\n\n      if (semver.prerelease(rootPkg.version)) {\n        core.info(`[root@${rootPkg.version}] Bumped to ${rootPkg.version} (prerelease)`)\n      }\n      else {\n        core.info(`[root@${rootPkg.version}] Bumped to ${rootPkg.version} (${workspaceBump})`)\n      }\n    }\n    else {\n      core.info(`[root@${rootPkg.version}] Skipping - strategy '${strategy}' with no changes needed`)\n    }\n  }\n  else if (workspaceBump && workspaceBump !== rootHistoricalBump) {\n    // Step 4: Use workspace bump if different from historical\n    const nextVersion = getNextVersion(rootPkg.version, workspaceBump, rootHistoricalBump, 'apply-bump')\n    rootPkg.version = nextVersion\n    await writeJSON(rootPackageJsonPath, rootPkg)\n\n    // Use git strategy to commit the root version change\n    await gitStrategy.commitVersionChange(process.cwd(), rootPkg.name || 'root', rootPkg.version, workspaceBump, commitMsgTemplate)\n\n    bumped[rootPkg.name] = { version: rootPkg.version, bumpType: workspaceBump, sha: null }\n    hasBumped = true\n\n    core.info(`[root@${rootPkg.version}] Bumped to ${rootPkg.version} (${workspaceBump})`)\n  }\n  else if (workspaceBump) {\n    core.info(`[root@${rootPkg.version}] No changes requiring version bump`)\n  }\n  else {\n    core.info(`[root] Root was bumped in workspace processing`)\n  }\n\n  return { bumped, hasBumped }\n}\n\nasync function generateSummary(bumped, testFailures, strategy, activeBranch, baseBranch, tagPrereleases, shouldFinalizeVersions) {\n  const totalPackages = Object.keys(bumped).length\n  const prereleasePackages = Object.values(bumped).filter(b => semver.prerelease(b.version)).length\n  const releasePackages = totalPackages - prereleasePackages\n  const finalizedPackages = Object.values(bumped).filter(b => b.bumpType === 'release').length\n\n  core.summary.addHeading('Version Bump Summary', 2)\n  core.summary.addTable([\n    [\n      { data: 'Package', header: true },\n      { data: 'Version', header: true },\n      { data: 'Bump Type', header: true },\n      { data: 'Previous Commit', header: true },\n      { data: 'Status', header: true },\n    ],\n    ...Object.entries(bumped).map(([name, { version, bumpType, sha }]) => [\n      { data: name },\n      { data: version },\n      { data: bumpType },\n      { data: sha?.slice(0, 7) || 'N/A' },\n      { data: testFailures.includes(name) ? ':x: Failed' : ':white_check_mark: Success' },\n    ]),\n  ])\n\n  // Add configuration summary\n  core.summary.addHeading('Configuration Used', 3)\n  core.summary.addList([\n    `Strategy: ${strategy}`,\n    `Active branch: ${activeBranch}`,\n    `Base branch: ${baseBranch || 'N/A'}`,\n    `Tag prereleases: ${tagPrereleases}`,\n    `Should finalize versions: ${shouldFinalizeVersions}`,\n  ])\n\n  // Add statistics\n  core.summary.addHeading('Statistics', 3)\n  core.summary.addList([\n    `Total packages processed: ${totalPackages}`,\n    `Release versions: ${releasePackages}`,\n    `Prerelease versions: ${prereleasePackages}`,\n    `Finalized versions: ${finalizedPackages}`,\n    `Test failures: ${testFailures.length}`,\n  ])\n\n  if (totalPackages > 0) {\n    core.info(`[summary] Processed ${totalPackages} packages: ${releasePackages} releases, ${prereleasePackages} prereleases, ${finalizedPackages} finalized`)\n    core.notice(`Version bump completed: ${totalPackages} packages updated (${releasePackages} releases, ${prereleasePackages} prereleases)`)\n  }\n  else {\n    core.info(`[summary] No packages required version changes with strategy '${strategy}'`)\n    core.notice(`No version changes needed with strategy '${strategy}'`)\n  }\n\n  // Set comprehensive outputs\n  core.setOutput('packages-updated', totalPackages)\n  core.setOutput('releases-created', releasePackages)\n  core.setOutput('prereleases-created', prereleasePackages)\n  core.setOutput('versions-finalized', finalizedPackages)\n  core.setOutput('test-failures', testFailures.length)\n  core.setOutput('strategy-used', strategy)\n  core.setOutput('changes-made', totalPackages > 0)\n\n  // Export useful environment variables\n  core.exportVariable('VERSION_BUMP_PACKAGES_UPDATED', totalPackages)\n  core.exportVariable('VERSION_BUMP_CHANGES_MADE', totalPackages > 0)\n  core.exportVariable('VERSION_BUMP_STRATEGY', strategy)\n\n  return { totalPackages, releasePackages, prereleasePackages, finalizedPackages }\n}\n\nasync function handleBranchOperations(newBranch, hasBumped, rootPkg, branchTemplate, branchCleanup, templateRegex, tagPrereleases, gitStrategy) {\n  let outputBranch = newBranch\n\n  // Branch and tag handling\n  if (newBranch && hasBumped) {\n    const versionedBranch = interpolate(branchTemplate, {\n      version: rootPkg.version,\n    })\n    const remoteVersionedBranch = `origin/${versionedBranch}`\n    const branches = await git.branch(['--list', '--remote'])\n    if (branches.all.includes(remoteVersionedBranch)) {\n      core.info(`[root] Deleting ${remoteVersionedBranch}`)\n      try {\n        await git.deleteLocalBranch(remoteVersionedBranch, true)\n      }\n      catch { }\n      try {\n        await git.deleteRemoteBranch(remoteVersionedBranch)\n      }\n      catch { }\n    }\n    core.info(`[root] Checking out ${versionedBranch} from ${newBranch}`)\n    await git.checkoutBranch(versionedBranch, newBranch)\n    core.info(`[root] Deleting ${newBranch}`)\n    await git.deleteLocalBranch(newBranch, true)\n    outputBranch = versionedBranch\n\n    const cleanupStrategy = BranchCleanupStrategyFactory.getStrategy(branchCleanup)\n    const rootBump = guessBumpType(rootPkg.version)\n    await cleanupStrategy.execute(branches, versionedBranch, templateRegex, rootBump)\n  }\n  else {\n    // Use git strategy to create tags\n    await gitStrategy.tagVersion(rootPkg.version, semver.prerelease(rootPkg.version), tagPrereleases)\n  }\n\n  return outputBranch\n}\n\nfunction interpolate(template, vars) {\n  return template.replace(/\\$\\{(\\w+)\\}/g, (_, v) => vars[v] ?? '')\n}\n\nfunction getPackageManager() {\n  return PackageManagerFactory.getPackageManager()\n}\n\nasync function readJSON(file) {\n  return JSON.parse(await fs.readFile(file, 'utf8'))\n}\n\nasync function writeJSON(file, data) {\n  await fs.writeFile(file, `${JSON.stringify(data, null, 2)}\\n`, 'utf8')\n}\n\nfunction initializeVersion(version) {\n  return semver.coerce(version) || '0.0.0'\n}\n\nfunction calculateBumpType(fromVersion, toVersion) {\n  const from = semver.coerce(fromVersion) || '0.0.0'\n  const to = semver.coerce(toVersion) || '0.0.0'\n  return semver.diff(from, to) // 'major', 'minor', 'patch', 'prerelease', null\n}\n\nfunction getNextVersion(currentVersion, commitBasedBump, historicalBump, strategyName = 'do-nothing') {\n  const current = semver.coerce(currentVersion) || '0.0.0'\n\n  // Validate inputs\n  if (commitBasedBump && !['major', 'minor', 'patch'].includes(commitBasedBump)) {\n    throw new Error(`Invalid commitBasedBump: ${commitBasedBump}`)\n  }\n\n  if (commitBasedBump === historicalBump) {\n    // Same bump type - use configured strategy\n    core.debug(`Same bump type detected (${commitBasedBump}), using strategy: ${strategyName}`)\n\n    const strategy = VersionBumpStrategyFactory.getStrategy(strategyName)\n    const nextVersion = strategy.execute(currentVersion, commitBasedBump, historicalBump)\n\n    // Handle do-nothing strategy return value\n    if (nextVersion === currentVersion && strategyName === 'do-nothing') {\n      return null // Skip bump\n    }\n\n    return nextVersion\n  }\n  else {\n    // Different bump type - normal semver bump (always apply)\n    const nextVersion = semver.inc(current, commitBasedBump)\n    core.debug(`Different bump type: ${current} → ${nextVersion} (${commitBasedBump})`)\n    return nextVersion\n  }\n}\n\n// Finalize prerelease versions when target is updated\nfunction finalizeVersion(version) {\n  const current = semver.coerce(version) || '0.0.0'\n  if (semver.prerelease(current)) {\n    // Remove prerelease suffix: 1.2.0-1 → 1.2.0\n    const parsed = semver.parse(current)\n    return `${parsed.major}.${parsed.minor}.${parsed.patch}`\n  }\n  return current\n}\n\nfunction getMostSignificantBump(commits) {\n  let bump = 'patch'\n  for (const c of commits) {\n    if (c.breaking)\n      return 'major'\n    if (c.type === 'feat' && bump !== 'major')\n      bump = 'minor'\n  }\n  return bump\n}\n\nfunction bumpPriority(type) {\n  if (type === 'major')\n    return 3\n  if (type === 'minor')\n    return 2\n  if (type === 'patch')\n    return 1\n  return 0\n}\n\nfunction parseCommits(log, sinceRef) {\n  const commits = []\n  for (const entry of log) {\n    const messageHeader = entry.message.split('\\n')[0]\n    if (sinceRef && entry.hash === sinceRef) {\n      core.debug(`Skipping commit ${entry.hash} because it is the same as the sinceRef: ${messageHeader}`)\n      continue\n    }\n    core.debug(`Parsing commit ${entry.hash}: ${messageHeader}`)\n    const parsed = conventionalCommitsParser.sync(entry.message)\n    const breaking = Boolean(parsed.notes && parsed.notes.find(n => n.title === 'BREAKING CHANGE')) || /!:/.test(parsed.header)\n    commits.push({\n      type: parsed.type,\n      scope: parsed.scope,\n      subject: parsed.subject,\n      breaking,\n      header: parsed.header,\n    })\n  }\n  return commits\n}\n\nasync function getPackageDirs(rootPkg) {\n  if (rootPkg.workspaces) {\n    // Support both array and object form\n    const patterns = Array.isArray(rootPkg.workspaces)\n      ? rootPkg.workspaces\n      : rootPkg.workspaces.packages\n    const dirs = new Set()\n    for (const pattern of patterns) {\n      for (const match of globSync(pattern, { cwd: process.cwd(), absolute: true })) {\n        // Only include dirs with package.json\n        try {\n          await fs.access(path.join(match, 'package.json'))\n          dirs.add(path.resolve(match))\n        }\n        catch { }\n      }\n    }\n    return Array.from(dirs)\n  }\n  else {\n    return [process.cwd()]\n  }\n}\n\nasync function buildDepGraph(pkgDirs) {\n  const graph = {}\n  const nameToDir = {}\n  for (const dir of pkgDirs) {\n    const pkg = await readJSON(path.join(dir, 'package.json'))\n    graph[pkg.name] = { dir, deps: [], pkg }\n    nameToDir[pkg.name] = dir\n  }\n  for (const name in graph) {\n    const { pkg } = graph[name]\n    const allDeps = { ...pkg.dependencies, ...pkg.devDependencies, ...pkg.peerDependencies }\n    for (const dep in allDeps) {\n      if (graph[dep])\n        graph[name].deps.push(dep)\n    }\n  }\n  return { graph, nameToDir }\n}\n\nfunction topoSort(graph) {\n  const visited = new Set()\n  const order = []\n  function visit(name) {\n    if (visited.has(name))\n      return\n    visited.add(name)\n    for (const dep of graph[name].deps) visit(dep)\n    order.push(name)\n  }\n  for (const name in graph) visit(name)\n  return order\n}\n\nasync function getCommitsAffecting(dir, sinceRef) {\n  // Get all commits affecting this dir since the reference\n  const range = sinceRef ? `${sinceRef}..HEAD` : 'HEAD'\n  const log = await git.log([range, '--', dir])\n  const commits = parseCommits(log.all, sinceRef)\n  core.info(`[${path.relative(process.cwd(), dir) || '/'}] ${commits.length} commits affecting since ${sinceRef}`)\n  return commits\n}\n\nfunction deleteRemoteBranch(branch) {\n  try {\n    execSync(`git push origin --delete ${branch}`)\n  }\n  catch { }\n}\n\nasync function lastNonMergeCommit(git, branch) {\n  try {\n    core.debug(`Getting last non-merge commit from branch: ${branch}`)\n    const commits = await git.log(['--no-merges', '-n1', branch])\n    if (!commits.latest) {\n      throw new Error(`No commits found in branch ${branch}`)\n    }\n    core.debug(`Last non-merge commit in ${branch}: ${commits.latest.hash}`)\n    return commits.latest.hash\n  }\n  catch (error) {\n    core.error(`Failed to get last non-merge commit from ${branch}: ${error.message}`)\n    throw new Error(`Failed to get last non-merge commit from ${branch}: ${error.message}`)\n  }\n}\n\nasync function main() {\n  let exitCode = 0\n  let outputBranch\n  let hasBumped = false\n\n  try {\n    // Step 1: Parse and validate configuration\n    const config = await parseConfiguration()\n    const { commitMsgTemplate, depCommitMsgTemplate, shouldCreateBranch, branchTemplate, templateRegex, branchCleanup, baseBranch, strategy, activeBranch, tagPrereleases } = config\n\n    // Step 2: Setup git and determine branches\n    const { currentBranch, newBranch } = await setupGit(shouldCreateBranch, branchTemplate)\n\n    // Step 3: Load root package and setup workspace\n    const rootDir = process.cwd()\n    const rootPkg = await readJSON(path.join(rootDir, 'package.json'))\n    const packageManager = getPackageManager()\n\n    // Initialize strategies\n    const gitStrategy = GitOperationStrategyFactory.getStrategy('conventional')\n    core.info(`[config] Package manager: ${packageManager.name}`)\n    core.info(`[config] Git strategy: ${gitStrategy.name}`)\n\n    // Step 4: Determine reference point for version comparison\n    const { referenceCommit, referenceVersion, shouldFinalizeVersions }\n      = await determineReferencePoint(baseBranch, activeBranch)\n\n    // Step 5: Discover packages and build dependency graph\n    const pkgDirs = await getPackageDirs(rootPkg)\n    const { graph, nameToDir } = await buildDepGraph(pkgDirs)\n    const order = topoSort(graph)\n\n    // Create Package instances for easier management\n    const packages = order.map((name) => {\n      const { dir, pkg } = graph[name]\n      const packageJsonPath = path.join(dir, 'package.json')\n      return new Package(name, dir, pkg, packageJsonPath)\n    })\n\n    let bumped = {}\n    let testFailures = []\n\n    // Step 6: Handle prerelease finalization or normal processing\n    if (shouldFinalizeVersions) {\n      const result = await finalizePackageVersions(packages, rootPkg, commitMsgTemplate, gitStrategy)\n      bumped = result.bumped\n      hasBumped = hasBumped || result.hasBumped\n    }\n    else {\n      // Step 6a: Process workspace packages\n      const workspaceResult = await processWorkspacePackages(\n        packages,\n        referenceCommit,\n        referenceVersion,\n        strategy,\n        commitMsgTemplate,\n        depCommitMsgTemplate,\n        gitStrategy,\n        packageManager,\n      )\n      bumped = workspaceResult.bumped\n      testFailures = workspaceResult.testFailures\n      hasBumped = hasBumped || Object.keys(bumped).length > 0\n\n      // Step 6b: Process root package\n      const rootResult = await processRootPackage(rootPkg, bumped, referenceCommit, referenceVersion, strategy, commitMsgTemplate, gitStrategy)\n      bumped = rootResult.bumped\n      if (rootResult.hasBumped)\n        hasBumped = true\n    }\n\n    // Step 7: Generate comprehensive summary and outputs\n    await generateSummary(bumped, testFailures, strategy, activeBranch, baseBranch, tagPrereleases, shouldFinalizeVersions)\n\n    // Step 8: Handle branch operations and cleanup\n    outputBranch = await handleBranchOperations(newBranch, hasBumped, rootPkg, branchTemplate, branchCleanup, templateRegex, tagPrereleases, gitStrategy)\n\n    // Step 9: Final validation and completion\n    if (hasBumped) {\n      core.info('✅ Version bump action completed successfully with changes')\n    }\n    else {\n      core.info('✅ Version bump action completed successfully with no changes needed')\n    }\n\n    // Validate final state\n    try {\n      const finalRootPkg = await readJSON(path.join(rootDir, 'package.json'))\n      if (finalRootPkg.version && !semver.valid(finalRootPkg.version)) {\n        throw new Error(`Final root package version is invalid: ${finalRootPkg.version}`)\n      }\n      core.debug(`[validation] Final root package version: ${finalRootPkg.version}`)\n      await gitStrategy.tagVersion(finalRootPkg.version, !!semver.prerelease(finalRootPkg.version), true)\n    }\n    catch (error) {\n      core.error(`[validation] Failed to validate final package state: ${error.message}`)\n      throw error\n    }\n  }\n  catch (err) {\n    console.error(err)\n    core.setFailed(err.message)\n    exitCode = 1\n  }\n  finally {\n    // Step 10: Push changes if any were made\n    if (hasBumped) {\n      try {\n        if (outputBranch) {\n          core.info(`[git] Pushing ${outputBranch} to origin`)\n          await git.push('origin', outputBranch, ['--set-upstream', '--force'])\n          core.setOutput('branch', outputBranch)\n          core.info(`[git] Successfully pushed ${outputBranch}`)\n        }\n        else {\n          core.info(`[git] Pushing current branch and tags`)\n          await git.push()\n          await git.pushTags()\n          core.info(`[git] Successfully pushed changes and tags`)\n        }\n      }\n      catch (error) {\n        core.error(`[git] Failed to push changes: ${error.message}`)\n        core.setFailed(`Failed to push changes: ${error.message}`)\n        exitCode = 1\n      }\n    }\n    else {\n      core.info(`[git] No changes to push`)\n    }\n  }\n  core.summary.write({ overwrite: true })\n  process.exit(exitCode)\n}\n\nfunction guessBumpType(version) {\n  if (version.endsWith('.0.0'))\n    return 'major'\n  if (version.endsWith('.0'))\n    return 'minor'\n  return 'patch'\n}\n\n// Add a stub for getVersionAtCommit to fix no-undef error\nasync function getVersionAtCommit() {\n  // TODO: Implement or replace with actual logic\n  return '0.0.0'\n}\n\nmain()\n","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/README.md","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/git-operations/base.cjs","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":39},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageName' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":52},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'version' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":61},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'bumpType' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":71},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'template' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":73,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":81},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":42},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageName' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":55},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'depName' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":64},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'depVersion' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":76},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'template' is defined but never used. Allowed unused args must match /^_/u.","line":11,"column":78,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":86},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'version' is defined but never used. Allowed unused args must match /^_/u.","line":15,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":27},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'isPrerelease' is defined but never used. Allowed unused args must match /^_/u.","line":15,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":41},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'shouldTag' is defined but never used. Allowed unused args must match /^_/u.","line":15,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":52}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Base class for git operation strategies\nclass GitOperationStrategy {\n  constructor(name) {\n    this.name = name\n  }\n\n  async commitVersionChange(packageDir, packageName, version, bumpType, template) {\n    throw new Error('Strategy must implement commitVersionChange method')\n  }\n\n  async commitDependencyUpdate(packageDir, packageName, depName, depVersion, template) {\n    throw new Error('Strategy must implement commitDependencyUpdate method')\n  }\n\n  async tagVersion(version, isPrerelease, shouldTag) {\n    throw new Error('Strategy must implement tagVersion method')\n  }\n}\n\nmodule.exports = { GitOperationStrategy }\n","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/git-operations/conventional.cjs","messages":[{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":11,"column":40,"nodeType":"Identifier","messageId":"preferModule","endLine":11,"endColumn":47},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":39,"column":40,"nodeType":"Identifier","messageId":"preferModule","endLine":39,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const path = require('node:path')\nconst core = require('@actions/core')\nconst { GitOperationStrategy } = require('./base.cjs')\n\nclass ConventionalCommitStrategy extends GitOperationStrategy {\n  constructor() {\n    super('conventional')\n  }\n\n  async commitVersionChange(packageDir, packageName, version, bumpType, template) {\n    const relativePath = path.relative(process.cwd(), packageDir) || '.'\n    const packageJsonPath = path.join(packageDir, 'package.json')\n\n    // Create conventional commit message\n    const msg = this.interpolate(template, {\n      package: packageName,\n      version,\n      bumpType,\n    })\n\n    try {\n      const git = require('simple-git')()\n\n      core.debug(`[${relativePath}] Adding package.json to git`)\n      await git.add([packageJsonPath])\n\n      core.debug(`[${relativePath}] Committing: ${msg}`)\n      await git.commit(msg)\n\n      core.debug(`[${relativePath}] Successfully committed version change`)\n    }\n    catch (error) {\n      core.error(`[${relativePath}] Failed to commit version change: ${error.message}`)\n      throw new Error(`Failed to commit version change in ${relativePath}: ${error.message}`)\n    }\n  }\n\n  async commitDependencyUpdate(packageDir, packageName, depName, depVersion, template) {\n    const relativePath = path.relative(process.cwd(), packageDir) || '.'\n    const packageJsonPath = path.join(packageDir, 'package.json')\n\n    const msg = this.interpolate(template, {\n      package: packageName,\n      depPackage: depName,\n      depVersion,\n      version: 'unknown', // We don't always have current version context\n      bumpType: 'patch',\n    })\n\n    try {\n      const git = require('simple-git')()\n\n      core.debug(`[${relativePath}] Adding package.json to git`)\n      await git.add([packageJsonPath])\n\n      core.debug(`[${relativePath}] Committing: ${msg}`)\n      await git.commit(msg)\n\n      core.debug(`[${relativePath}] Successfully committed dependency update`)\n    }\n    catch (error) {\n      core.error(`[${relativePath}] Failed to commit dependency update: ${error.message}`)\n      throw new Error(`Failed to commit dependency update in ${relativePath}: ${error.message}`)\n    }\n  }\n\n  async tagVersion(version, isPrerelease, shouldTag) {\n    const tagName = `v${version}`\n    const git = require('simple-git')()\n\n    if (!version) {\n      core.warning('No version found, skipping tag')\n      return\n    }\n\n    if (isPrerelease && !shouldTag) {\n      core.info(`Skipping prerelease tag ${tagName} (use tag-prereleases: true to enable)`)\n      return\n    }\n\n    try {\n      const existingTags = await git.tags()\n      if (existingTags.all.includes(tagName)) {\n        core.info(`Skipping tag ${tagName} because it already exists`)\n        return\n      }\n\n      if (isPrerelease) {\n        core.info(`Creating prerelease tag ${tagName}`)\n      }\n      else {\n        core.info(`Creating release tag ${tagName}`)\n      }\n\n      await git.addAnnotatedTag(tagName, `Release ${version}`)\n    }\n    catch (error) {\n      core.error(`Failed to create tag ${tagName}: ${error.message}`)\n      throw new Error(`Failed to create tag ${tagName}: ${error.message}`)\n    }\n  }\n\n  interpolate(template, vars) {\n    return template.replace(/\\$\\{(\\w+)\\}/g, (_, v) => vars[v] ?? '')\n  }\n}\n\nmodule.exports = { ConventionalCommitStrategy }\n","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/git-operations/factory.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/git-operations/index.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/git-operations/simple.cjs","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'bumpType' is defined but never used. Allowed unused args must match /^_/u.","line":10,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":71},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'template' is defined but never used. Allowed unused args must match /^_/u.","line":10,"column":73,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":81},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":11,"column":40,"nodeType":"Identifier","messageId":"preferModule","endLine":11,"endColumn":47},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'template' is defined but never used. Allowed unused args must match /^_/u.","line":29,"column":78,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":86},{"ruleId":"node/prefer-global/process","severity":2,"message":"Unexpected use of the global variable 'process'. Use 'require(\"process\")' instead.","line":30,"column":40,"nodeType":"Identifier","messageId":"preferModule","endLine":30,"endColumn":47}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const path = require('node:path')\nconst core = require('@actions/core')\nconst { GitOperationStrategy } = require('./base.cjs')\n\nclass SimpleCommitStrategy extends GitOperationStrategy {\n  constructor() {\n    super('simple')\n  }\n\n  async commitVersionChange(packageDir, packageName, version, bumpType, template) {\n    const relativePath = path.relative(process.cwd(), packageDir) || '.'\n    const packageJsonPath = path.join(packageDir, 'package.json')\n\n    // Simple commit message\n    const msg = `Bump ${packageName} to ${version}`\n\n    try {\n      const git = require('simple-git')()\n\n      await git.add([packageJsonPath])\n      await git.commit(msg)\n      core.debug(`[${relativePath}] Successfully committed simple version change`)\n    }\n    catch (error) {\n      throw new Error(`Failed to commit version change in ${relativePath}: ${error.message}`)\n    }\n  }\n\n  async commitDependencyUpdate(packageDir, packageName, depName, depVersion, template) {\n    const relativePath = path.relative(process.cwd(), packageDir) || '.'\n    const packageJsonPath = path.join(packageDir, 'package.json')\n\n    const msg = `Update ${depName} to ${depVersion} in ${packageName}`\n\n    try {\n      const git = require('simple-git')()\n\n      await git.add([packageJsonPath])\n      await git.commit(msg)\n      core.debug(`[${relativePath}] Successfully committed simple dependency update`)\n    }\n    catch (error) {\n      throw new Error(`Failed to commit dependency update in ${relativePath}: ${error.message}`)\n    }\n  }\n\n  async tagVersion(version, isPrerelease, shouldTag) {\n    if (!version || (isPrerelease && !shouldTag))\n      return\n\n    const tagName = `v${version}`\n    const git = require('simple-git')()\n\n    try {\n      await git.addTag(tagName)\n      core.info(`Created simple tag ${tagName}`)\n    }\n    catch (error) {\n      core.error(`Failed to create tag ${tagName}: ${error.message}`)\n    }\n  }\n}\n\nmodule.exports = { SimpleCommitStrategy }\n","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/index.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/base.cjs","messages":[{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is assigned a value but never used. Allowed unused args must match /^_/u.","line":11,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":27},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is assigned a value but never used. Allowed unused args must match /^_/u.","line":15,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":24},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is assigned a value but never used. Allowed unused args must match /^_/u.","line":19,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":25},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is assigned a value but never used. Allowed unused args must match /^_/u.","line":23,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":31},{"ruleId":"unused-imports/no-unused-vars","severity":2,"message":"'packageDir' is assigned a value but never used. Allowed unused args must match /^_/u.","line":27,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":28}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Base class for package manager strategies\nclass PackageManagerStrategy {\n  constructor(name) {\n    this.name = name\n  }\n\n  isAvailable() {\n    throw new Error('Strategy must implement isAvailable method')\n  }\n\n  async install(packageDir = '.') {\n    throw new Error('Strategy must implement install method')\n  }\n\n  async test(packageDir = '.') {\n    throw new Error('Strategy must implement test method')\n  }\n\n  async build(packageDir = '.') {\n    throw new Error('Strategy must implement build method')\n  }\n\n  getInstallCommand(packageDir = '.') {\n    throw new Error('Strategy must implement getInstallCommand method')\n  }\n\n  getTestCommand(packageDir = '.') {\n    throw new Error('Strategy must implement getTestCommand method')\n  }\n}\n\nexports.PackageManagerStrategy = PackageManagerStrategy\n","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/factory.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/index.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/npm.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/pnpm.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lib/package-managers/yarn.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/lint-report.json","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Expected to be an expression, but got empty.","line":1,"column":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"","usedDeprecatedRules":[]},{"filePath":"/Users/bahulneel/Projects/bahulneel/action-version/package.json","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
